package alternativeto

import (
	"fmt"
	"os"
	"sort"
	"strings"
)

func GenerateMainREADME() (err error) {
	var lines = []string{
		"# alternativeto",
		"A comprehensive list of alternatives to your favorite software.",
		"",
		"**Please do not edit this file directly. Instead, follow the steps outlined in the [Contributing Guidelines](https://github.com/brentadamson/alternativeto/blob/main/.github/contributing.md)**",
		"",
		"## Index",
	}

	// create the index
	sortedCategories := []string{}
	for _, company := range allCompanies {
		if contains(sortedCategories, company.Category) {
			continue
		}
		sortedCategories = append(sortedCategories, company.Category)
	}
	sort.Strings(sortedCategories)
	for _, category := range sortedCategories {
		lines = append(lines, fmt.Sprintf("* [%s](#%s)", category, strings.ToLower(strings.ReplaceAll(category, " ", "-"))))
	}

	platformIOS = "iOS"
	platformGoogleSheetsAddOn = "Google Sheets Add-on"
	platformLinux = "Linux"
	platformMac = "Mac"
	platformWeb = "web"
	platformWindows = "Windows"

	// add the companies
	for _, category := range sortedCategories {
		lines = append(lines, "")
		lines = append(lines, fmt.Sprintf("### %s", category))
		lines = append(lines, fmt.Sprintf("Website | %s | Open Source", strings.Join(allPlatforms, " | ")))
		lines = append(lines, "|---|---|---|---|---|---|---|---|")

		var companies []Company
		for _, company := range allCompanies {
			if company.Category != category {
				continue
			}
			companies = append(companies, company)
		}

		sort.Slice(companies, func(i, j int) bool {
			return companies[i].Name < companies[j].Name
		})

		for _, company := range companies {
			var yesNo = "No"
			if company.OpenSource {
				yesNo = "Yes"
			}

			var marks []string
			for _, platform := range allPlatforms {
				var mark = ":negative_squared_cross_mark:"
				if contains(company.Platforms, platform) {
					mark = ":heavy_check_mark:"
				}
				marks = append(marks, mark)
			}

			lines = append(lines, fmt.Sprintf(`| [%s](%s) | %s | %s |`, company.Name, company.Website, strings.Join(marks, " | "), yesNo))
		}

		lines = append(lines, "")
		lines = append(lines, "**[â¬† Back to Index](#index)**")
		lines = append(lines, "")
	}

	var contents = []byte(strings.Join(lines, "\n") + "\n")
	return os.WriteFile("README.md", contents, 0644)
}

func contains(s []string, str string) bool {
	for _, v := range s {
		if v == str {
			return true
		}
	}

	return false
}
